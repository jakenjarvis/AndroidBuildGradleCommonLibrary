// CommonLibrary.gradle
def thisname = "CommonLibrary"
println "Loading ${thisname}"

apply plugin: CommonLibraryPlugin

class CommonLibraryPlugin implements Plugin<Project> {

    private def rootProject = null
    private def listLoading = []

    void apply(Project project) {
        this.rootProject = project.rootProject
        project.extensions.create("commonlibrary", CommonLibraryPluginExtension, this)

        boolean rootDirEnabled = project.commonlibrary.rootDir?.trim()
        if(!rootDirEnabled) {
            println "Find rootDir"
            def findroot = project.fileTree(dir: this.rootProject.projectDir, include: "CommonLibrary.gradle")
            if(!findroot.isEmpty()) {
                project.commonlibrary.rootDir = findroot.getSingleFile().getParent()
            } else {
                project.commonlibrary.rootDir = new File(this.rootProject.projectDir, "/gradle/library")
            }
        }

        println "AndroidBuildGradleCommonLibrary: ${project.commonlibrary.rootDir}"
    }

    def getRootProject()
    {
        return this.rootProject
    }

    def findModuleByFrom(project, from)
    {
        def tree = project.fileTree(this.rootProject.commonlibrary.rootDir)
                .include("**/*${from}*.gradle")
                .exclude("CommonLibrary.gradle")
        if(tree.isEmpty())
        {
            throw new Exception("Module can not be found: ${from}")
        }
        return tree.getSingleFile()
    }

    def apply(project, key, module)
    {
        if(this.listLoading.contains(key))
        {
            throw new Exception("apply is not possible to read in duplicate modules in one project: ${module.toString()} in ${project.name}")
        }
        this.listLoading.add(key)

        // Injection of module: "apply from: module"
        project.apply(from: module)
    }


}

class CommonLibraryPluginExtension {

    def File rootDir = null

    private def rootPlugin = null

    CommonLibraryPluginExtension(plugin)
    {
        this.rootPlugin = plugin
    }

    //def apply(from)
    //{
    //    this.apply(this.rootPlugin.getRootProject(), from)
    //}

    def apply(project, from)
    {
        // TODO: How to identify a project of the caller? I want to eliminate the project argument...

        def thisCommonLibrary = new File(project.commonlibrary.rootDir, "CommonLibrary.gradle")
        if(!thisCommonLibrary.exists()) {
            throw new Exception("Path to the root directory of CommonLibrary is invalid: ${project.commonlibrary.rootDir}. Please set the correct path to [project.commonlibrary.rootDir].")
        }

        def module = this.rootPlugin.findModuleByFrom(project, from)
        def key
        if(module ==~ /(?i).*(allprojects|subprojects).*/)
        {
            key = "${module.toString()}"
        }
        else
        {
            key = "${project.name}_${module.toString()}"
        }
        this.rootPlugin.apply(project, key, module)
    }
}
