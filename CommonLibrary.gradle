// CommonLibrary.gradle
def thisname = "CommonLibrary"
println "Loading ${thisname}"

apply plugin: CommonLibraryPlugin

class CommonLibraryPlugin implements Plugin<Project> {

    private def rootProject = null
    private def listLoading = []

    void apply(Project project) {
        this.rootProject = project.rootProject
        project.extensions.create("commonlibrary", CommonLibraryPluginExtension, this)

        boolean rootDirEnabled = project.commonlibrary.rootDir?.trim()
        if(!rootDirEnabled) {
            println "Find rootDir"
            def findroot = project.fileTree(dir: this.rootProject.projectDir, include: "CommonLibrary.gradle")
            if(!findroot.isEmpty()) {
                project.commonlibrary.rootDir = findroot.getSingleFile().getParent()
            } else {
                project.commonlibrary.rootDir = new File(this.rootProject.projectDir, "/gradle")
            }
        }

        println "AndroidBuildGradleCommonLibrary: ${project.commonlibrary.rootDir}"
    }

    def getRootProject()
    {
        return this.rootProject
    }

    def findModuleByFrom(project, from)
    {
        File result
        def tree = project.fileTree(this.rootProject.commonlibrary.rootDir)
                .include("**/*${from}*.gradle")
                .exclude("CommonLibrary.gradle")
        if(tree.isEmpty())
        {
            throw new Exception("Module can not be found: ${from}")
        }
        else if(tree.getFiles().size() >= 2)
        {
            FileTree filtered = tree.matching {
                include("**/*${from}.gradle")
            }
            if(filtered.getFiles().size() == 1)
            {
                result = filtered.getSingleFile()
            }
            else
            {
                throw new Exception("Failed to identify the module: ${from}")
            }
        }
        else
        {
            result = tree.getSingleFile()
        }
        return result
    }

    def apply(project, key, module)
    {
        if(this.listLoading.contains(key))
        {
            throw new Exception("apply is not possible to read in duplicate modules in one project: ${module.toString()} in ${project.name}")
        }
        this.listLoading.add(key)

        // Injection of module: "apply from: module"
        project.apply(from: module)
    }

}

class CommonLibraryPluginExtension {

    def File rootDir = null

    private def rootPlugin = null

    CommonLibraryPluginExtension(plugin)
    {
        this.rootPlugin = plugin
    }

    //def apply(from)
    //{
    //    this.apply(this.rootPlugin.getRootProject(), from)
    //}

    def apply(project, from)
    {
        // TODO: How to identify a project of the caller? I want to eliminate the project argument...

        def module = this.rootPlugin.findModuleByFrom(project, from)
        def key
        if(module ==~ /(?i).*(allprojects|subprojects).*/)
        {
            key = "${module.toString()}"
        }
        else
        {
            key = "${project.name}_${module.toString()}"
        }
        this.rootPlugin.apply(project, key, module)
    }

    def generateArchiveName(AbstractArchiveTask task, variant) {
        // http://www.gradle.org/docs/current/dsl/org.gradle.api.tasks.bundling.Zip.html#org.gradle.api.tasks.bundling.Zip:archiveName
        // Default ArchiveName: ${baseName}-${appendix}-${version}-${classifier}.${extension}
        def noneBaseName = task.baseName ?: ""
        def hyphenAppendix = task.appendix ? "-${task.appendix}" : ""
        def hyphenVariantName = variant?.baseName ? "-${variant.baseName}" : ""

        def hyphenSignedApk
        if(variant) {
            // MEMO: I want to solve dynamically without import for the project coexistence of Android and Java.
            try{
                hyphenSignedApk = variant.isSigningReady() ? "-unaligned" : "-unsigned"
            }catch (MissingMethodException e) {
                hyphenSignedApk = ""
            }
        } else {
            hyphenSignedApk = ""
        }

        def hyphenVersion = task.version ? "-${task.version}" : ""
        def hyphenClassifier = task.classifier ? "-${task.classifier}" : ""
        def periodExtension = task.extension ? ".${task.extension}" : ""
        return "${noneBaseName}${hyphenAppendix}${hyphenVariantName}${hyphenSignedApk}${hyphenVersion}${hyphenClassifier}${periodExtension}"
    }

}
